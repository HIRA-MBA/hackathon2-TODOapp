# GitHub Actions Deploy to Oracle Cloud OKE Workflow
# Builds all images, pushes to OCIR, installs prerequisites, and deploys to OKE

name: Deploy to OKE

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  OCI_CLI_REGION: ${{ secrets.OCI_CLI_REGION }}
  REGISTRY: ${{ secrets.OCI_CLI_REGION }}.ocir.io
  NAMESPACE: ${{ secrets.OCIR_NAMESPACE }}
  HELM_RELEASE: todo-chatbot
  K8S_NAMESPACE: production

jobs:
  # Build and push all images to OCIR
  build-push:
    name: Build & Push Images
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.version }}
    steps:
      - uses: actions/checkout@v4

      - name: Generate image tag
        id: meta
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          echo "version=${SHORT_SHA}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to OCIR
        run: |
          echo "${{ secrets.OCIR_TOKEN }}" | docker login \
            ${{ env.REGISTRY }} \
            -u "${{ secrets.OCIR_USERNAME }}" \
            --password-stdin

      # Build Backend
      - name: Build and push backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.NAMESPACE }}/todo-backend:${{ steps.meta.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.NAMESPACE }}/todo-backend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build Frontend
      - name: Build and push frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.NAMESPACE }}/todo-frontend:${{ steps.meta.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.NAMESPACE }}/todo-frontend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build WebSocket Service
      - name: Build and push websocket-service
        uses: docker/build-push-action@v5
        with:
          context: ./services/websocket
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.NAMESPACE }}/websocket-service:${{ steps.meta.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.NAMESPACE }}/websocket-service:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build Recurring Task Service
      - name: Build and push recurring-task-service
        uses: docker/build-push-action@v5
        with:
          context: ./services/recurring-task
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.NAMESPACE }}/recurring-task-service:${{ steps.meta.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.NAMESPACE }}/recurring-task-service:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build Notification Service
      - name: Build and push notification-service
        uses: docker/build-push-action@v5
        with:
          context: ./services/notification
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.NAMESPACE }}/notification-service:${{ steps.meta.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.NAMESPACE }}/notification-service:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Deploy to OKE
  deploy:
    name: Deploy to OKE
    runs-on: ubuntu-latest
    needs: build-push
    environment: production
    env:
      OCI_CLI_USER: ${{ secrets.OCI_CLI_USER }}
      OCI_CLI_TENANCY: ${{ secrets.OCI_CLI_TENANCY }}
      OCI_CLI_FINGERPRINT: ${{ secrets.OCI_CLI_FINGERPRINT }}
      OCI_CLI_KEY_CONTENT: ${{ secrets.OCI_CLI_KEY_CONTENT }}
      OCI_CLI_REGION: ${{ secrets.OCI_CLI_REGION }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure kubectl for OKE
        uses: oracle-actions/configure-kubectl-oke@v1.5.0
        with:
          cluster: ${{ secrets.OKE_CLUSTER_OCID }}

      - name: Verify cluster connection
        run: |
          echo "=== Cluster Nodes ==="
          kubectl get nodes -o wide
          echo ""
          echo "=== Node Architecture ==="
          kubectl get nodes -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.nodeInfo.architecture}{"\t"}{.status.nodeInfo.osImage}{"\n"}{end}'

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.14.0

      # --- Install cluster prerequisites ---

      - name: Install NGINX Ingress Controller
        run: |
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx \
            --create-namespace \
            --set controller.service.type=LoadBalancer \
            --set controller.service.annotations."oci\.oraclecloud\.com/load-balancer-type"=nlb \
            --timeout 5m
          echo "Waiting for NGINX Ingress Controller pod..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=180s || echo "Warning: Ingress controller not fully ready yet, continuing..."

      - name: Install Dapr on cluster
        run: |
          # Install Dapr CLI
          wget -q https://raw.githubusercontent.com/dapr/cli/master/install/install.sh -O - | /bin/bash -s 1.14.0

          # Check if Dapr is already installed
          if dapr status -k 2>/dev/null | grep -q "Running"; then
            echo "Dapr is already installed and running."
          else
            echo "Installing Dapr on the cluster..."
            dapr init -k --runtime-version 1.14.4 --wait --timeout 300
          fi

          echo "=== Dapr Status ==="
          dapr status -k

      # --- Prepare namespace and secrets ---

      - name: Create namespace
        run: kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create OCIR pull secret
        run: |
          kubectl create secret docker-registry ocir-secret \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username='${{ secrets.OCIR_USERNAME }}' \
            --docker-password='${{ secrets.OCIR_TOKEN }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Redpanda credentials secret
        run: |
          kubectl create secret generic redpanda-credentials \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --from-literal=brokers='${{ secrets.REDPANDA_BROKERS }}' \
            --from-literal=saslUsername='${{ secrets.REDPANDA_USERNAME }}' \
            --from-literal=saslPassword='${{ secrets.REDPANDA_PASSWORD }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      # --- Clean up broken state from previous failed deploys ---

      - name: Clean up stuck resources
        run: |
          echo "Cleaning up stuck resources from previous failed deploys..."
          # Force-delete terminating pods
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} --no-headers 2>/dev/null \
            | grep -i terminating | awk '{print $1}' \
            | xargs -r kubectl delete pod -n ${{ env.K8S_NAMESPACE }} --grace-period=0 --force 2>/dev/null || true
          # Delete failed pods
          kubectl delete pods --field-selector=status.phase=Failed -n ${{ env.K8S_NAMESPACE }} --ignore-not-found=true 2>/dev/null || true
          echo "Cleanup complete."

      # --- Deploy ---

      - name: Deploy Helm chart
        run: |
          helm upgrade --install ${{ env.HELM_RELEASE }} ./helm/todo-chatbot \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --values ./helm/values-oke.yaml \
            --set global.imageTag=${{ needs.build-push.outputs.image_tag }} \
            --set global.registry=${{ env.REGISTRY }}/${{ env.NAMESPACE }} \
            --set secrets.databaseUrl="${{ secrets.DATABASE_URL }}" \
            --set secrets.betterAuthSecret="${{ secrets.BETTER_AUTH_SECRET }}" \
            --set secrets.openaiApiKey="${{ secrets.OPENAI_API_KEY }}" \
            --set dapr.pubsub.brokers="${{ secrets.REDPANDA_BROKERS }}" \
            --timeout 10m

      # --- Verify ---

      - name: Wait for rollouts
        run: |
          echo "Waiting for deployments to roll out..."
          kubectl rollout status deployment/${{ env.HELM_RELEASE }}-redis -n ${{ env.K8S_NAMESPACE }} --timeout=3m || true
          kubectl rollout status deployment/${{ env.HELM_RELEASE }}-backend -n ${{ env.K8S_NAMESPACE }} --timeout=5m || true
          kubectl rollout status deployment/${{ env.HELM_RELEASE }}-frontend -n ${{ env.K8S_NAMESPACE }} --timeout=5m || true
          kubectl rollout status deployment/${{ env.HELM_RELEASE }}-websocket -n ${{ env.K8S_NAMESPACE }} --timeout=3m || true
          kubectl rollout status deployment/${{ env.HELM_RELEASE }}-recurring-task -n ${{ env.K8S_NAMESPACE }} --timeout=3m || true
          kubectl rollout status deployment/${{ env.HELM_RELEASE }}-notification -n ${{ env.K8S_NAMESPACE }} --timeout=3m || true

      - name: Deployment status
        if: always()
        run: |
          echo "============================================"
          echo "=== DEPLOYMENT STATUS ==="
          echo "============================================"
          echo ""
          echo "=== Pods ==="
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} -o wide
          echo ""
          echo "=== Services ==="
          kubectl get svc -n ${{ env.K8S_NAMESPACE }}
          echo ""
          echo "=== Ingress ==="
          kubectl get ingress -n ${{ env.K8S_NAMESPACE }}
          echo ""
          echo "=== Dapr Components ==="
          kubectl get components -n ${{ env.K8S_NAMESPACE }} 2>/dev/null || echo "No Dapr components found"
          echo ""
          echo "=== Ingress Controller ==="
          kubectl get svc -n ingress-nginx
          echo ""
          echo "=== Pod Details (non-Running pods) ==="
          for pod in $(kubectl get pods -n ${{ env.K8S_NAMESPACE }} --no-headers 2>/dev/null | grep -v Running | awk '{print $1}'); do
            echo "--- Pod: $pod ---"
            kubectl describe pod "$pod" -n ${{ env.K8S_NAMESPACE }} 2>/dev/null | tail -25
            echo "--- Logs: $pod ---"
            kubectl logs "$pod" -n ${{ env.K8S_NAMESPACE }} --tail=15 2>/dev/null || echo "No logs available"
            echo ""
          done
          echo ""
          echo "=== Recent Events ==="
          kubectl get events -n ${{ env.K8S_NAMESPACE }} --sort-by='.lastTimestamp' 2>/dev/null | tail -20

      - name: Show access info
        if: always()
        run: |
          echo "============================================"
          echo "=== ACCESS YOUR APP ==="
          echo "============================================"
          LB_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          echo ""
          echo "Load Balancer IP: $LB_IP"
          echo ""
          if [ "$LB_IP" != "pending" ] && [ -n "$LB_IP" ]; then
            echo "Frontend:    http://$LB_IP/"
            echo "Backend API: http://$LB_IP/api/health"
            echo "WebSocket:   ws://$LB_IP/ws"
          else
            echo "LoadBalancer IP is still being provisioned."
            echo "Check with: kubectl get svc -n ingress-nginx"
          fi
